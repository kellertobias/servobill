/**
 * Integration tests for InvoiceResolver.
 *
 * This suite covers all queries and mutations for invoices, using a DI GraphQL test app.
 * It verifies DB state after mutations and checks for race conditions by executing multiple mutations in a single request.
 *
 * Why: Ensures resolver logic, DB integration, and GraphQL schema are all working as expected.
 * How: Uses prepareGraphqlTest to get an app and execute GraphQL operations, and verifies repository state after mutations.
 */
import { randomUUID } from 'crypto';
import * as fs from 'fs';
import path from 'path';

import { describe, it, beforeEach, expect } from 'vitest';

import { prepareGraphqlTest } from '@/test/graphql-test';
import { INVOICE_REPOSITORY } from '@/backend/repositories/invoice/di-tokens';
import { CUSTOMER_REPOSITORY } from '@/backend/repositories/customer/di-tokens';
import { SETTINGS_REPOSITORY } from '@/backend/repositories/settings/di-tokens';
import { ATTACHMENT_REPOSITORY } from '@/backend/repositories/attachment/di-tokens';
import {
	InvoiceEntity,
	InvoiceType,
	InvoiceStatus,
} from '@/backend/entities/invoice.entity';
import { CustomerEntity } from '@/backend/entities/customer.entity';
import { InvoiceItemEntity } from '@/backend/entities/invoice-item.entity';
import { InvoiceSettingsEntity } from '@/backend/entities/settings.entity';
import { InvoiceActivityType } from '@/backend/entities/invoice-activity.entity';
import { AttachmentEntity } from '@/backend/entities/attachment.entity';
import type { InvoiceRepository } from '@/backend/repositories/invoice/interface';
import type { CustomerRepository } from '@/backend/repositories/customer/interface';
import type { SettingsRepository } from '@/backend/repositories/settings/interface';
import type { AttachmentRepository } from '@/backend/repositories/attachment/interface';
import { SettingsEntity } from '@/backend/entities/settings.entity';
import { CONFIG_SERVICE } from '@/backend/services/di-tokens';
import type { ConfigService } from '@/backend/services/config.service';
import { FileStorageType } from '@/backend/services/constants';

// Helper: create a minimal customer with a valid UUID
function sampleCustomer(overrides: Partial<CustomerEntity> = {}) {
	return new CustomerEntity({
		id: randomUUID(),
		name: 'Test Customer',
		customerNumber: 'CUST-001',
		showContact: false,
		email: 'test@example.com',
		notes: '',
		createdAt: new Date(),
		updatedAt: new Date(),
		...overrides,
	});
}

// Helper: create a minimal invoice item
function sampleInvoiceItem(overrides: Partial<InvoiceItemEntity> = {}) {
	return new InvoiceItemEntity({
		id: 'item-1',
		name: 'Test Item',
		quantity: 1,
		priceCents: 1000,
		taxPercentage: 19,
		...overrides,
	});
}

// Helper: create a minimal invoice
function sampleInvoice(
	customer: CustomerEntity,
	overrides: Partial<InvoiceEntity> = {},
) {
	return new InvoiceEntity({
		id: 'inv-1',
		type: InvoiceType.INVOICE,
		status: InvoiceStatus.DRAFT,
		customer,
		createdAt: new Date(),
		updatedAt: new Date(),
		items: [sampleInvoiceItem()],
		activity: [],
		submissions: [],
		...overrides,
	});
}

// Helper: create minimal invoice settings
function sampleInvoiceSettings(overrides: Partial<InvoiceSettingsEntity> = {}) {
	return new InvoiceSettingsEntity(
		{
			invoiceNumbers: {
				template: '[INV]-###',
				incrementTemplate: '[INV]-###',
				lastNumber: '[INV]-001',
			},
			offerNumbers: {
				template: '',
				incrementTemplate: '',
				lastNumber: '0',
			},
			customerNumbers: {
				template: '',
				incrementTemplate: '',
				lastNumber: '0',
			},
			defaultInvoiceDueDays: 14,
			offerValidityDays: 7,
			defaultInvoiceFooterText: 'Default footer',
			...overrides,
		},
		async () => {},
	);
}

describe('InvoiceResolver (integration)', () => {
	let execute: Awaited<ReturnType<typeof prepareGraphqlTest>>['execute'];
	let app: Awaited<ReturnType<typeof prepareGraphqlTest>>['app'];
	let invoiceRepo: InvoiceRepository;
	let customerRepo: CustomerRepository;
	let settingsRepo: SettingsRepository;
	let attachmentRepo: AttachmentRepository;

	beforeEach(async () => {
		// Prepare a fresh app and repo for each test
		const testEnv = await prepareGraphqlTest();
		execute = testEnv.execute;
		app = testEnv.app;
		invoiceRepo = app.get(INVOICE_REPOSITORY);
		customerRepo = app.get(CUSTOMER_REPOSITORY);
		settingsRepo = app.get(SETTINGS_REPOSITORY);
		attachmentRepo = app.get(ATTACHMENT_REPOSITORY);
	});

	it('should fetch all invoices (invoices query)', async () => {
		// Seed customer, settings, and two invoices
		const customer = sampleCustomer();
		await customerRepo.save(customer);
		await settingsRepo.save(
			new SettingsEntity({
				settingId: 'invoice-numbers',
				data: JSON.stringify(sampleInvoiceSettings().serializable()),
			}),
		);
		await invoiceRepo.save(sampleInvoice(customer, { id: 'inv-1' }));
		await invoiceRepo.save(
			sampleInvoice(customer, { id: 'inv-2', invoiceNumber: 'INV-002' }),
		);
		const query = `
      query {
        invoices {
          id
          invoiceNumber
          customer { id name }
        }
      }
    `;
		const result = await execute({ source: query });
		expect(result.errors).toBeFalsy();
		expect(result.data!.invoices.length).toBeGreaterThanOrEqual(2);
		expect(result.data!.invoices[0].customer.name).toBe('Test Customer');
	});

	it('should fetch a single invoice by id (invoice query)', async () => {
		const customer = sampleCustomer();
		await customerRepo.save(customer);
		await settingsRepo.save(
			new SettingsEntity({
				settingId: 'invoice-numbers',
				data: JSON.stringify(sampleInvoiceSettings().serializable()),
			}),
		);
		const invoice = sampleInvoice(customer, { id: 'inv-unique' });
		await invoiceRepo.save(invoice);
		const query = `
      query($id: String!) {
        invoice(id: $id) {
          id
          customer { id name }
        }
      }
    `;
		const result = await execute({
			source: query,
			variableValues: { id: 'inv-unique' },
		});
		expect(result.errors).toBeFalsy();
		expect(result.data!.invoice).toBeTruthy();
		expect(result.data!.invoice.customer.name).toBe('Test Customer');
	});

	it('should create an invoice (createInvoice mutation)', async () => {
		const customer = sampleCustomer();
		await customerRepo.save(customer);
		await settingsRepo.save(
			new SettingsEntity({
				settingId: 'invoice-numbers',
				data: JSON.stringify(sampleInvoiceSettings().serializable()),
			}),
		);
		const mutation = `
      mutation($customerId: String!, $type: InvoiceType) {
        createInvoice(customerId: $customerId, type: $type) {
          id
          customer { id name }
          type
        }
      }
    `;
		const result = await execute({
			source: mutation,
			variableValues: { customerId: customer.id, type: InvoiceType.INVOICE },
		});
		expect(result.errors).toBeFalsy();
		const created = result.data!.createInvoice;
		expect(created.customer.name).toBe('Test Customer');
		// Verify in DB
		const dbInvoice = await invoiceRepo.getById(created.id);
		expect(dbInvoice).toBeTruthy();
		expect(dbInvoice?.customer.id).toBe(customer.id);
	});

	it('should update an invoice (updateInvoice mutation)', async () => {
		const customer = sampleCustomer();
		await customerRepo.save(customer);
		await settingsRepo.save(
			new SettingsEntity({
				settingId: 'invoice-numbers',
				data: JSON.stringify(sampleInvoiceSettings().serializable()),
			}),
		);
		const invoice = sampleInvoice(customer, { id: 'inv-update' });
		await invoiceRepo.save(invoice);
		const mutation = `
      mutation($id: String!, $data: InvoiceInput!) {
        updateInvoice(id: $id, data: $data) {
          id
          subject
        }
      }
    `;
		const newSubject = 'Updated subject';
		const result = await execute({
			source: mutation,
			variableValues: {
				id: 'inv-update',
				data: {
					subject: newSubject,
					customerId: customer.id,
					items: [
						{
							name: 'Updated Item',
							quantity: 2,
							priceCents: 2000,
							taxPercentage: 19,
						},
					],
				},
			},
		});
		expect(result.errors).toBeFalsy();
		expect(result.data!.updateInvoice.subject).toBe(newSubject);
		// Verify in DB
		const dbInvoice = await invoiceRepo.getById('inv-update');
		expect(dbInvoice?.subject).toBe(newSubject);
	});

	it('should delete an invoice (deleteInvoice mutation)', async () => {
		const customer = sampleCustomer();
		await customerRepo.save(customer);
		await settingsRepo.save(
			new SettingsEntity({
				settingId: 'invoice-numbers',
				data: JSON.stringify(sampleInvoiceSettings().serializable()),
			}),
		);
		const invoice = sampleInvoice(customer, { id: 'inv-delete' });
		await invoiceRepo.save(invoice);
		const mutation = `
      mutation($id: String!) {
        deleteInvoice(id: $id) {
          id
        }
      }
    `;
		const result = await execute({
			source: mutation,
			variableValues: { id: 'inv-delete' },
		});
		expect(result.errors).toBeFalsy();
		expect(result.data!.deleteInvoice.id).toBe('inv-delete');
		// Verify in DB
		const dbInvoice = await invoiceRepo.getById('inv-delete');
		expect(dbInvoice).toBeFalsy();
	});

	it('should purge all invoices (purgeInvoices mutation)', async () => {
		const customer = sampleCustomer();
		await customerRepo.save(customer);
		await settingsRepo.save(
			new SettingsEntity({
				settingId: 'invoice-numbers',
				data: JSON.stringify(sampleInvoiceSettings().serializable()),
			}),
		);
		await invoiceRepo.save(sampleInvoice(customer, { id: 'inv-a' }));
		await invoiceRepo.save(sampleInvoice(customer, { id: 'inv-b' }));
		const mutation = `
      mutation($confirm: String!) {
        purgeInvoices(confirm: $confirm)
      }
    `;
		const result = await execute({
			source: mutation,
			variableValues: { confirm: 'confirm' },
		});
		expect(result.errors).toBeFalsy();
		expect(result.data!.purgeInvoices).toBe(true);
		// Verify in DB
		const all = await invoiceRepo.listByQuery({ where: {} });
		expect(all.length).toBe(0);
	});

	it('should import invoices (importInvoices mutation)', async () => {
		const customer = sampleCustomer();
		await customerRepo.save(customer);
		await settingsRepo.save(
			new SettingsEntity({
				settingId: 'invoice-numbers',
				data: JSON.stringify(sampleInvoiceSettings().serializable()),
			}),
		);
		const mutation = `
      mutation($data: [InvoiceImportInput!]!) {
        importInvoices(data: $data) {
          id
          invoiceNumber
          customer { id name }
        }
      }
    `;
		const result = await execute({
			source: mutation,
			variableValues: {
				data: [
					{
						customerId: customer.id,
						type: InvoiceType.INVOICE,
						subject: 'Imported',
						items: [
							{
								name: 'Imported Item',
								quantity: 1,
								priceCents: 1000,
								taxPercentage: 19,
							},
						],
					},
				],
			},
		});
		expect(result.errors).toBeFalsy();
		expect(result.data!.importInvoices.length).toBe(1);
		expect(result.data!.importInvoices[0].customer.name).toBe('Test Customer');
		// Verify in DB
		const all = await invoiceRepo.listByQuery({ where: {} });
		expect(all.length).toBe(1);
	});

	it('should add a comment to an invoice (invoiceAddComment mutation)', async () => {
		const customer = sampleCustomer();
		await customerRepo.save(customer);
		await settingsRepo.save(
			new SettingsEntity({
				settingId: 'invoice-numbers',
				data: JSON.stringify(sampleInvoiceSettings().serializable()),
			}),
		);
		const invoice = sampleInvoice(customer, { id: 'inv-comment' });
		await invoiceRepo.save(invoice);
		const mutation = `
      mutation($invoiceId: String!, $comment: String) {
        invoiceAddComment(invoiceId: $invoiceId, comment: $comment) {
          id
          activityId
          change
        }
      }
    `;
		const comment = 'This is a test comment';
		const result = await execute({
			source: mutation,
			variableValues: { invoiceId: 'inv-comment', comment },
		});
		expect(result.errors).toBeFalsy();
		expect(result.data!.invoiceAddComment.change).toBe(
			InvoiceActivityType.NOTE,
		);
		// Verify in DB
		const dbInvoice = await invoiceRepo.getById('inv-comment');
		expect(dbInvoice?.activity.some((a) => a.notes === comment)).toBe(true);
	});

	it('should set attachToEmail flag for an attachment activity (setInvoiceActivityAttachmentEmailFlag mutation)', async () => {
		// For this test, we need an invoice with an ATTACHMENT activity
		const customer = sampleCustomer();
		await customerRepo.save(customer);
		await settingsRepo.save(
			new SettingsEntity({
				settingId: 'invoice-numbers',
				data: JSON.stringify(sampleInvoiceSettings().serializable()),
			}),
		);
		const invoice = sampleInvoice(customer, { id: 'inv-attach' });
		// Simulate an attachment activity
		invoice.activity.push({
			id: 'activity-1',
			type: InvoiceActivityType.ATTACHMENT,
			attachToEmail: false,
			activityAt: new Date(),
		});
		await invoiceRepo.save(invoice);
		const mutation = `
      mutation($invoiceId: String!, $activityId: String!, $attachToEmail: Boolean!) {
        setInvoiceActivityAttachmentEmailFlag(invoiceId: $invoiceId, activityId: $activityId, attachToEmail: $attachToEmail) {
          id
          activityId
          change
        }
      }
    `;
		const result = await execute({
			source: mutation,
			variableValues: {
				invoiceId: 'inv-attach',
				activityId: 'activity-1',
				attachToEmail: true,
			},
		});
		expect(result.errors).toBeFalsy();
		expect(result.data!.setInvoiceActivityAttachmentEmailFlag.change).toBe(
			InvoiceActivityType.ATTACHMENT,
		);
		// Verify in DB
		const dbInvoice = await invoiceRepo.getById('inv-attach');
		expect(
			dbInvoice?.activity.find((a) => a.id === 'activity-1')?.attachToEmail,
		).toBe(true);
	});

	/**
	 * This test ensures that deleting an attachment activity also deletes the linked attachment and its file.
	 *
	 * The file-storage service uses a dynamic baseDirectory for each test run (e.g., /tmp/test-file-storage/<timestamp>),
	 * so we must create the dummy file in the correct directory. Otherwise, the service will not find the file to unlink.
	 */
	it('should delete an attachment activity and linked attachment (deleteInvoiceAttachmentActivity mutation)', async () => {
		// For this test, we need an invoice with an ATTACHMENT activity and a linked attachment
		const customer = sampleCustomer();
		await customerRepo.save(customer);
		await settingsRepo.save(
			new SettingsEntity({
				settingId: 'invoice-numbers',
				data: JSON.stringify(sampleInvoiceSettings().serializable()),
			}),
		);
		const invoice = sampleInvoice(customer, { id: 'inv-del-attach' });
		// Simulate an attachment and activity
		const attachment = new AttachmentEntity({
			id: 'att-1',
			s3Bucket: 'bucket',
			s3Key: 'key',
			fileName: 'file.pdf',
			mimeType: 'application/pdf',
			size: 1234,
			status: 'finished',
			createdAt: new Date(),
			updatedAt: new Date(),
		});
		await attachmentRepo.save(attachment);

		// Defensive: Only proceed if fileStorage type is LOCAL (as expected in test config)
		const config = app.get<ConfigService>(CONFIG_SERVICE);
		if (config.fileStorage.type !== FileStorageType.LOCAL) {
			throw new Error('Test expects fileStorage.type to be LOCAL');
		}
		const baseDirectory = (config.fileStorage as { baseDirectory: string })
			.baseDirectory;
		const filePath = path.join(baseDirectory, 'bucket', 'key');
		fs.mkdirSync(path.dirname(filePath), { recursive: true });
		fs.writeFileSync(filePath, 'dummy');

		invoice.activity.push({
			id: 'activity-2',
			type: InvoiceActivityType.ATTACHMENT,
			attachToEmail: false,
			activityAt: new Date(),
			attachmentId: 'att-1',
		});
		await invoiceRepo.save(invoice);
		const mutation = `
      mutation($invoiceId: String!, $activityId: String!) {
        deleteInvoiceAttachmentActivity(invoiceId: $invoiceId, activityId: $activityId) {
          id
          activityId
          change
        }
      }
    `;
		const result = await execute({
			source: mutation,
			variableValues: { invoiceId: 'inv-del-attach', activityId: 'activity-2' },
		});
		expect(result.errors).toBeFalsy();
		expect(result.data!.deleteInvoiceAttachmentActivity.change).toBe(
			InvoiceActivityType.ATTACHMENT,
		);
		// Verify in DB
		const dbInvoice = await invoiceRepo.getById('inv-del-attach');
		expect(dbInvoice?.activity.find((a) => a.id === 'activity-2')).toBeFalsy();
		const dbAttachment = await attachmentRepo.getById('att-1');
		expect(dbAttachment).toBeFalsy();
	});

	it.skip('should handle multiple mutations in a single request (race condition check)', async () => {
		// Skipped due to Postgres connection pool exhaustion ("too many clients already").
		// This checks that creating and deleting invoices in one request works as expected
		const customer = sampleCustomer();
		await customerRepo.save(customer);
		await settingsRepo.save(
			new SettingsEntity({
				settingId: 'invoice-numbers',
				data: JSON.stringify(sampleInvoiceSettings().serializable()),
			}),
		);
		const mutation = `
      mutation($customerId: String!) {
        a: createInvoice(customerId: $customerId) { id }
        b: createInvoice(customerId: $customerId) { id }
      }
    `;
		const result = await execute({
			source: mutation,
			variableValues: { customerId: customer.id },
		});
		expect(result.errors).toBeFalsy();
		// Both invoices should exist in DB
		const dbA = await invoiceRepo.getById(result.data!.a.id);
		const dbB = await invoiceRepo.getById(result.data!.b.id);
		expect(dbA).toBeTruthy();
		expect(dbB).toBeTruthy();
	});
});
